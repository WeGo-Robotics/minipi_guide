<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>OpenCV란? | Mini Pi Guide</title>
    <meta name="description" content="2족 보행 로봇 활용">
    <meta name="generator" content="VitePress v2.0.0-alpha.13">
    <link rel="preload stylesheet" href="/minipi_guide/assets/style._jmpxg3s.css" as="style">
    <link rel="preload stylesheet" href="/minipi_guide/vp-icons.css" as="style">
    
    <script type="module" src="/minipi_guide/assets/app.Bw4myUDB.js"></script>
    <link rel="preload" href="/minipi_guide/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/minipi_guide/assets/chunks/theme.DFC_Kh8m.js">
    <link rel="modulepreload" href="/minipi_guide/assets/chunks/framework.Bb6kz8E2.js">
    <link rel="modulepreload" href="/minipi_guide/assets/robot-app_opencv.md.Bllbrakc.lean.js">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
    <link href="https://fonts.googleapis.com/css2?family=Chiron+GoRound+TC:wght@200..900&amp;display=swap" rel="stylesheet">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-1df9f90f><!--[--><!--]--><!--[--><span tabindex="-1" data-v-331ec75c></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-331ec75c>Skip to content</a><!--]--><!----><header class="VPNav" data-v-1df9f90f data-v-9f75dce3><div class="VPNavBar" data-v-9f75dce3 data-v-2a96a3d0><div class="wrapper" data-v-2a96a3d0><div class="container" data-v-2a96a3d0><div class="title" data-v-2a96a3d0><div class="VPNavBarTitle has-sidebar" data-v-2a96a3d0 data-v-1e38c6bc><a class="title" href="/minipi_guide/" data-v-1e38c6bc><!--[--><!--]--><!----><span data-v-1e38c6bc>Mini Pi Guide</span><!--[--><!--]--></a></div></div><div class="content" data-v-2a96a3d0><div class="content-body" data-v-2a96a3d0><!--[--><!--]--><div class="VPNavBarSearch search" data-v-2a96a3d0><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-2a96a3d0 data-v-39714824><span id="main-nav-aria-label" class="visually-hidden" data-v-39714824> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/minipi_guide/" tabindex="0" data-v-39714824 data-v-52a1d768><!--[--><span data-v-52a1d768>Home</span><!--]--></a><!--]--><!--[--><a class="VPLink link vp-external-link-icon VPNavBarMenuLink" href="https://wego-robotics.com/" target="_blank" rel="noreferrer" tabindex="0" data-v-39714824 data-v-52a1d768><!--[--><span data-v-52a1d768>WeGo</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-2a96a3d0 data-v-6c893767><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-6c893767 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-2a96a3d0 data-v-0394ad82 data-v-d07f11e6><!--[--><a class="VPSocialLink no-icon" href="https://github.com/WeGo-Robotics" aria-label="github" target="_blank" rel="me noopener" data-v-d07f11e6 data-v-591a6b30><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-2a96a3d0 data-v-bf2fac68 data-v-42cb505d><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-42cb505d><span class="vpi-more-horizontal icon" data-v-42cb505d></span></button><div class="menu" data-v-42cb505d><div class="VPMenu" data-v-42cb505d data-v-25a6cce8><!----><!--[--><!--[--><!----><div class="group" data-v-bf2fac68><div class="item appearance" data-v-bf2fac68><p class="label" data-v-bf2fac68>Appearance</p><div class="appearance-action" data-v-bf2fac68><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-bf2fac68 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div></div></div><div class="group" data-v-bf2fac68><div class="item social-links" data-v-bf2fac68><div class="VPSocialLinks social-links-list" data-v-bf2fac68 data-v-d07f11e6><!--[--><a class="VPSocialLink no-icon" href="https://github.com/WeGo-Robotics" aria-label="github" target="_blank" rel="me noopener" data-v-d07f11e6 data-v-591a6b30><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-2a96a3d0 data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><div class="divider" data-v-2a96a3d0><div class="divider-line" data-v-2a96a3d0></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-1df9f90f data-v-8acdfeb5><div class="container" data-v-8acdfeb5><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-8acdfeb5><span class="vpi-align-left menu-icon" data-v-8acdfeb5></span><span class="menu-text" data-v-8acdfeb5>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-8acdfeb5 data-v-0bf0e06f><button data-v-0bf0e06f>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-1df9f90f data-v-d9ac16f8><div class="curtain" data-v-d9ac16f8></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-d9ac16f8><span class="visually-hidden" id="sidebar-aria-label" data-v-d9ac16f8> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-8d50c081><section class="VPSidebarItem level-0 has-active" data-v-8d50c081 data-v-d81de50c><div class="item" role="button" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><h2 class="text" data-v-d81de50c>Mini Pi 로봇의 응용</h2><!----></div><div class="items" data-v-d81de50c><!--[--><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/minipi_guide/robot-app/" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>개요</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/minipi_guide/robot-app/basic.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>기본 사용법</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/minipi_guide/robot-app/node.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>노드 매니저</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/minipi_guide/robot-app/move.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>로봇의 이동</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/minipi_guide/robot-app/webui.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>웹UI 다루기</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/minipi_guide/robot-app/remote.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>원격 제어</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/minipi_guide/robot-app/opencv.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>물체 추적</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/minipi_guide/robot-app/qrcode.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>마커 인식</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-1df9f90f data-v-aff0b8d7><div class="VPDoc has-sidebar has-aside" data-v-aff0b8d7 data-v-7011f0d8><!--[--><!--]--><div class="container" data-v-7011f0d8><div class="aside" data-v-7011f0d8><div class="aside-curtain" data-v-7011f0d8></div><div class="aside-container" data-v-7011f0d8><div class="aside-content" data-v-7011f0d8><div class="VPDocAside" data-v-7011f0d8 data-v-3f215769><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-3f215769 data-v-60d5052e><div class="content" data-v-60d5052e><div class="outline-marker" data-v-60d5052e></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-60d5052e>On this page</div><ul class="VPDocOutlineItem root" data-v-60d5052e data-v-1ce71065><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-7011f0d8><div class="content-container" data-v-7011f0d8><!--[--><!--]--><main class="main" data-v-7011f0d8><div style="position:relative;" class="vp-doc _minipi_guide_robot-app_opencv" data-v-7011f0d8><div><h1 id="opencv란" tabindex="-1">OpenCV란? <a class="header-anchor" href="#opencv란" aria-label="Permalink to “OpenCV란?”">​</a></h1><p>OpenCV(Open Source Computer Vision Library)는 <strong>이미지와 영상 처리·분석을 위한 오픈소스 라이브러리</strong>입니다.<br> 카메라로부터 입력된 화면을 분석하여 <strong>사물을 인식하고 판단하는 역할</strong>을 수행합니다.</p><h2 id="opencv를-사용하는-이유" tabindex="-1">OpenCV를 사용하는 이유 <a class="header-anchor" href="#opencv를-사용하는-이유" aria-label="Permalink to “OpenCV를 사용하는 이유”">​</a></h2><p>OpenCV를 사용하는 이유는 다음과 같습니다.</p><table tabindex="0"><thead><tr><th>기능</th><th>설명</th><th>로봇 적용 예시</th></tr></thead><tbody><tr><td>이미지 분석</td><td>색, 윤곽선, 객체 형태 인식</td><td>공/사람 인식</td></tr><tr><td>영상 처리</td><td>실시간 카메라 프레임 처리</td><td>라인 추적 로봇</td></tr><tr><td>위치 계산</td><td>객체 중심점, 거리 추정</td><td>목표 추적 및 장애물 회피</td></tr><tr><td>제어 연결</td><td>분석 결과를 ROS 등으로 전달</td><td>로봇 속도 제어</td></tr></tbody></table><blockquote><p>즉, <strong>로봇에게 눈(vision)을 제공하는 핵심 기술</strong>입니다.</p></blockquote><h2 id="opencv-영상-처리-흐름" tabindex="-1">OpenCV 영상 처리 흐름 <a class="header-anchor" href="#opencv-영상-처리-흐름" aria-label="Permalink to “OpenCV 영상 처리 흐름”">​</a></h2><div class="tip custom-block"><p class="custom-block-title">OpenCV 영상 처리 단계</p><p>카메라 영상 취득 -&gt; 이미지 데이터 변환 -&gt; 이미지 전처리 -&gt; 이미지에서 데이터 추출</p></div><ol><li><strong>카메라에서 영상 취득</strong> : 시스템에 연결된 카메라를 선택하고 해상도나 밝기 등의 설정을 한 후 영상을 캡쳐합니다.</li><li><strong>이미지 전처리</strong> : BGR -&gt; RGB -&gt; HSV 등으로 형식을 변환하고 이미지의 밝기, 대비, 색온도 등의 항목을 수정해 데이터 추출이 용이하게 합니다.</li><li><strong>이미지에서 데이터 추출</strong> : 이미지에서 색상, 엣지, 도형, 마커 등의 의미있는 데이터를 등을 추출합니다.</li></ol><div class="tip custom-block"><p class="custom-block-title">주의사항</p><p>OpenCV는 일반적인 RGB 순서가 아닌 BGR (Blue, Green, Red) 순서를 기본으로 사용합니다. (CV_8UC3일 때 0번 채널이 Blue입니다.)</p></div><h2 id="특정-색상-찾기-예제" tabindex="-1">특정 색상 찾기 예제 <a class="header-anchor" href="#특정-색상-찾기-예제" aria-label="Permalink to “특정 색상 찾기 예제”">​</a></h2><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numpy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> np</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 1. 카메라 설정</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cap </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv2.VideoCapture(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 파란색 범위 설정 (이전 시간 복습)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">lower_blue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> np.array([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">upper_blue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> np.array([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">140</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">255</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">255</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># ★ 핵심 변수: 인식할 최소 면적 (픽셀 수)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 이 값보다 작은 덩어리는 무시합니다. (값을 조절해보세요)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MIN_AREA</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 500</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;파란색 물체를 찾아 박스를 그립니다. (종료: q)&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> True</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ret, frame </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cap.read()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> not</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ret:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        break</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 2. 색상 추출 (HSV 변환 및 마스크 생성)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    hsv </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv2.cvtColor(frame, cv2.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">COLOR_BGR2HSV</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    mask </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv2.inRange(hsv, lower_blue, upper_blue)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # (옵션) 모폴로지 연산: 노이즈를 제거하여 마스크를 깔끔하게 만듦</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 파란색 영역의 구멍을 메우거나 자잘한 점을 없앰</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    kernel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> np.ones((</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), np.uint8)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    mask </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv2.morphologyEx(mask, cv2.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MORPH_OPEN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, kernel)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    mask </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv2.morphologyEx(mask, cv2.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MORPH_CLOSE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, kernel)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 3. 외곽선(Contour) 검출</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # cv2.RETR_EXTERNAL: 가장 바깥쪽 라인만 찾음 (구멍 뚫린 내부 라인 무시)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # cv2.CHAIN_APPROX_SIMPLE: 직선 구간은 끝점만 저장해 메모리 절약</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    contours, _ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv2.findContours(mask, cv2.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RETR_EXTERNAL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, cv2.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CHAIN_APPROX_SIMPLE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 4. 발견된 모든 외곽선 순회</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cnt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> contours:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # 면적 계산</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        area </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv2.contourArea(cnt)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # ★ 크기 필터링: 면적이 설정값보다 클 때만 박스 그리기</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> area </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MIN_AREA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            # 외곽선을 감싸는 정사각 박스 좌표 구하기</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            # x, y: 시작점 좌표 / w, h: 폭과 높이</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            x, y, w, h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv2.boundingRect(cnt)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            # 원본 화면에 녹색 박스 그리기 (두께 2)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            cv2.rectangle(frame, (x, y), (x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> w, y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> h), (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">255</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            # 박스 위에 &quot;Blue Object&quot; 글자 쓰기</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            cv2.putText(frame, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Blue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (x, y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                        cv2.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FONT_HERSHEY_SIMPLEX</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">255</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 결과 출력</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    cv2.imshow(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Camera&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, frame)       </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 박스가 그려진 원본</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    cv2.imshow(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Mask&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, mask)          </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 흑백 마스크 (디버깅용)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv2.waitKey(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FF</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ord</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;q&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        break</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cap.release()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cv2.destroyAllWindows()</span></span></code></pre></div><h2 id="카메라에서-영상-취득-capture" tabindex="-1">카메라에서 영상 취득 (Capture) <a class="header-anchor" href="#카메라에서-영상-취득-capture" aria-label="Permalink to “카메라에서 영상 취득 (Capture)”">​</a></h2><p>OpenCV에서 동영상 파일이나 카메라 스트림을 다룰 때는 VideoCapture 클래스를 사용합니다.</p><div style="display:flex;justify-content:center;gap:20px;"><img src="/minipi_guide/assets/cv_orignal.uCjgXWXH.png" alt="원본" style="width:45%;"></div><h3 id="주요-함수-설명" tabindex="-1">주요 함수 설명 <a class="header-anchor" href="#주요-함수-설명" aria-label="Permalink to “주요 함수 설명”">​</a></h3><ol><li><strong>cv2.VideoCapture(index)</strong> : VideoCapture 클래스 생성</li></ol><div class="info custom-block"><p class="custom-block-title">index</p><p>카메라 장치 번호를 지정합니다.</p><p>0: 보통 노트북의 내장 웹캠 혹은 첫 번째 연결된 카메라.</p><p>1, 2...: 추가로 연결된 USB 카메라.</p><p>&quot;video.mp4&quot;: 파일 경로를 넣으면 동영상을 재생합니다.</p></div><ol start="2"><li><strong>cap.read()</strong> : 영상을 한 프레임(한 장의 사진)씩 가져옵니다.</li></ol><div class="danger custom-block"><p class="custom-block-title">리턴값</p><p>(성공여부 Bool, 이미지배열 Numpy) 튜플을 반환하므로 반드시 두 변수로 받아야 합니다.</p></div><ol start="3"><li><strong>cv2.waitKey(delay)</strong> : 이 함수가 없으면 창이 뜨지 않거나 멈춥니다.</li></ol><div class="info custom-block"><p class="custom-block-title">delay</p><p>밀리초(ms) 단위 대기 시간입니다.</p><p>1: 1ms만 대기하고 다음 코드로 넘어감 (동영상/카메라용).</p><p>0: 키를 누를 때까지 무한 대기 (정지 영상용).</p></div><div class="danger custom-block"><p class="custom-block-title">리턴값</p><p>눌린 키의 아스키 코드 값입니다.</p></div><ol start="4"><li><strong>cap.release()</strong> : 프로그램이 끝날 때 카메라 장치 사용 권한을 운영체제에 반환해야 합니다. 그렇지 않으면 다른 프로그램(Zoom, Skype 등)에서 카메라를 쓰지 못할 수 있습니다.</li></ol><div class="warning custom-block"><p class="custom-block-title">실습 과제</p><ol><li><strong>기초</strong>: 위 코드를 실행하여 자기 얼굴 띄우기.</li><li><strong>응용 1 (좌우 반전)</strong>: 거울처럼 보이게 cv2.flip(frame, 1) 적용해보기.</li><li><strong>응용 2 (필터 적용)</strong>: cv2.cvtColor를 이용해 흑백(Grayscale) 영상으로 송출하기.</li><li><strong>응용 3 (캡처)</strong>: &#39;s&#39; 키를 누르면 현재 화면을 이미지 파일(my_photo.jpg)로 저장하기. (cv2.imwrite 사용)</li></ol></div><h2 id="이미지-전처리" tabindex="-1">이미지 전처리 <a class="header-anchor" href="#이미지-전처리" aria-label="Permalink to “이미지 전처리”">​</a></h2><ul><li>BGR → HSV 변환</li><li>파란색만 추출(Mask 생성)</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 2. 색상 추출 (HSV 변환 및 마스크 생성)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">hsv </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv2.cvtColor(frame, cv2.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">COLOR_BGR2HSV</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mask </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv2.inRange(hsv, lower_blue, upper_blue)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># (옵션) 모폴로지 연산: 노이즈를 제거하여 마스크를 깔끔하게 만듦</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 파란색 영역의 구멍을 메우거나 자잘한 점을 없앰</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">kernel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> np.ones((</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), np.uint8)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mask </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv2.morphologyEx(mask, cv2.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MORPH_OPEN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, kernel)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mask </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv2.morphologyEx(mask, cv2.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MORPH_CLOSE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, kernel)</span></span></code></pre></div><h3 id="주요-함수-설명-1" tabindex="-1">주요 함수 설명 <a class="header-anchor" href="#주요-함수-설명-1" aria-label="Permalink to “주요 함수 설명”">​</a></h3><ol><li><p><strong>cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)</strong> : 사람의 눈이 색을 인지하는 방식과 비슷하게 데이터를 바꾸는 과정입니다. 이 줄이 없으면 파란색 인식이 매우 불안정해집니다.</p></li><li><p><strong>cv2.inRange(src, lower, upper)</strong> : 이미지를 이진화(Binarization) 합니다.</p></li></ol><div class="info custom-block"><p class="custom-block-title">lower ~ upper</p><p>사이의 값은 255(흰색), 범위 밖은 <strong>0(검은색)</strong>으로 바꿉니다. 결과물인 mask는 흑백 이미지가 됩니다. 흰색 영역이 우리가 찾은 &quot;파란색 물체&quot;의 위치입니다.</p></div><ol start="3"><li><strong>cv2.morphologyEx(src, op, kernel, iterations=1)</strong> : OpenCV에서 고급 모폴로지(Morphology) 연산을 수행하는 범용 함수입니다. 한마디로 요약하면: <strong>&quot;이미지의 잡음(작은 흰색 점)을 제거하면서, 원래 물체의 크기는 보존하는 연산&quot;</strong>입니다.</li></ol><div class="info custom-block"><p class="custom-block-title">파라미터 설명</p><ul><li><strong><code>src</code></strong>: 입력 이미지 (주로 흑백 바이너리 이미지 또는 그레이스케일 이미지)</li><li><strong><code>op</code></strong>: 수행할 연산의 종류 (가장 중요한 파라미터, 아래 3번 항목 참조)</li><li><strong><code>kernel</code></strong>: 구조 요소(Structuring Element). <code>cv2.getStructuringElement()</code>나 <code>np.ones()</code>로 생성한 커널 행렬.</li><li><strong><code>iterations</code></strong> (선택): 연산 반복 횟수 (기본값은 1)</li></ul></div><div class="info custom-block"><p class="custom-block-title">주요 연산 종류 (<code>op</code> 옵션)</p><p>이 함수는 두 번째 인자(<code>op</code>)에 무엇을 넣느냐에 따라 기능이 완전히 달라집니다.</p><table tabindex="0"><thead><tr><th style="text-align:left;">옵션 상수 (<code>op</code>)</th><th style="text-align:left;">이름</th><th style="text-align:left;">동작 원리</th><th style="text-align:left;">주요 용도</th></tr></thead><tbody><tr><td style="text-align:left;"><strong><code>cv2.MORPH_OPEN</code></strong></td><td style="text-align:left;"><strong>열기 (Opening)</strong></td><td style="text-align:left;">침식 후 팽창<br>(Erosion → Dilation)</td><td style="text-align:left;"><strong>노이즈 제거</strong>, 작은 돌기 제거, 서로 붙은 물체 떼어내기</td></tr><tr><td style="text-align:left;"><strong><code>cv2.MORPH_CLOSE</code></strong></td><td style="text-align:left;"><strong>닫기 (Closing)</strong></td><td style="text-align:left;">팽창 후 침식<br>(Dilation → Erosion)</td><td style="text-align:left;"><strong>구멍 메우기</strong>, 끊어진 물체 이어 붙이기</td></tr><tr><td style="text-align:left;"><strong><code>cv2.MORPH_GRADIENT</code></strong></td><td style="text-align:left;"><strong>그라디언트</strong></td><td style="text-align:left;">팽창 - 침식<br>(Dilation - Erosion)</td><td style="text-align:left;"><strong>경계선(Edge) 검출</strong>, 물체의 외곽선 찾기</td></tr><tr><td style="text-align:left;"><strong><code>cv2.MORPH_TOPHAT</code></strong></td><td style="text-align:left;"><strong>탑햇 (Top Hat)</strong></td><td style="text-align:left;">원본 - 열기<br>(Src - Opening)</td><td style="text-align:left;"><strong>밝은 부분 강조</strong>, 배경이 어두울 때 국소적으로 밝은 미세한 부분 검출</td></tr><tr><td style="text-align:left;"><strong><code>cv2.MORPH_BLACKHAT</code></strong></td><td style="text-align:left;"><strong>블랙햇 (Black Hat)</strong></td><td style="text-align:left;">닫기 - 원본<br>(Closing - Src)</td><td style="text-align:left;"><strong>어두운 부분 강조</strong>, 배경이 밝을 때 국소적으로 어두운 미세한 부분 검출</td></tr></tbody></table></div><p>아래 사진은 모폴로지(Morphology) 처리를 하기 전과 후이다.</p><div style="display:flex;justify-content:center;gap:20px;"><img src="/minipi_guide/assets/cv_mask.D2Wjza8G.png" alt="원본 마스크" style="width:45%;"><img src="/minipi_guide/assets/cv_2.RFnKcGZ2.png" alt="모폴로지 연산 후" style="width:45%;"></div><h3 id="hsv를-왜-쓰는가" tabindex="-1">HSV를 왜 쓰는가? <a class="header-anchor" href="#hsv를-왜-쓰는가" aria-label="Permalink to “HSV를 왜 쓰는가?”">​</a></h3><p>카메라에서 들어오는 원본 이미지는 보통 <strong>BGR</strong>형식입니다.<br> 하지만 BGR에서는 밝기 변화(조명)에 따라 같은 물체도 값이 크게 바뀌어서 색으로 물체를 찾기 까다롭습니다.<br> 그래서 색 추적에는 보통 <strong>HSV(Hue, Saturation, Value)</strong> 색공간을 사용합니다.</p><ul><li><strong>H(Hue)</strong> : 색상(빨강, 초록, 파랑 등), OpenCV에서 H의 범위: 0 ~ 179</li><li><strong>S(Saturation)</strong> : 색의 진함 정도 (원색에 가까운지)</li><li><strong>V(Value)</strong> : 색의 밝기</li></ul><p>💡 <strong>핵심</strong>: HSV 모델에서는 밝기(V)가 변해도 색상(H) 값은 거의 변하지 않으므로 특정 색을 검출하기 훨씬 쉽습니다.</p><p>HSV 범위 지정은 다음과 같이 작성할 수 있습니다.</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span># 파란색 영역 마스크 생성 (Hue: 100~140)</span></span>
<span class="line"><span>lower_blue = np.array([100, 100, 50])</span></span>
<span class="line"><span>upper_blue = np.array([140, 255, 255])</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 빨간색은 Hue 값이 0 근처와 180 근처 두 군데에 존재함</span></span>
<span class="line"><span>lower_red1 = np.array([0, 50, 50])</span></span>
<span class="line"><span>upper_red1 = np.array([10, 255, 255])</span></span>
<span class="line"><span>lower_red2 = np.array([170, 50, 50])</span></span>
<span class="line"><span>upper_red2 = np.array([180, 255, 255])</span></span>
<span class="line"><span></span></span>
<span class="line"><span>mask1 = cv2.inRange(hsv, lower_red1, upper_red1)</span></span>
<span class="line"><span>mask2 = cv2.inRange(hsv, lower_red2, upper_red2)</span></span>
<span class="line"><span>mask = mask1 + mask2 # 두 마스크 합치기</span></span></code></pre></div><p>각 값들 순서대로 H, S, V이며 현재 예시로 되어있는 코드는 파란색을 인식하도록 되어있습니다.</p><h2 id="이미지에서-데이터-추출" tabindex="-1">이미지에서 데이터 추출 <a class="header-anchor" href="#이미지에서-데이터-추출" aria-label="Permalink to “이미지에서 데이터 추출”">​</a></h2><ul><li>이진화된 이미지(Mask)에서 <strong>외곽선(Contour)</strong>을 찾을 수 있다.</li><li><strong>contourArea</strong>를 사용하여 작은 노이즈(잡음)는 무시하고, 큰 물체만 골라낸다.</li><li>물체의 위치를 계산하여 <strong>사각형 박스(Bounding Box)</strong>를 그릴 수 있다.</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 면적 계산</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">area </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv2.contourArea(cnt)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># ★ 크기 필터링: 면적이 설정값보다 클 때만 박스 그리기</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> area </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MIN_AREA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 외곽선을 감싸는 정사각 박스 좌표 구하기</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # x, y: 시작점 좌표 / w, h: 폭과 높이</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    x, y, w, h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv2.boundingRect(cnt)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 원본 화면에 녹색 박스 그리기 (두께 2)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    cv2.rectangle(frame, (x, y), (x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> w, y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> h), (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">255</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><div style="display:flex;justify-content:center;gap:20px;"><img src="/minipi_guide/assets/cv_1.BYN24Z-o.png" alt="원본 마스크" style="width:45%;"><img src="/minipi_guide/assets/cv_2.RFnKcGZ2.png" alt="모폴로지 연산 후" style="width:45%;"></div><h3 id="주요-함수-설명-2" tabindex="-1">주요 함수 설명 <a class="header-anchor" href="#주요-함수-설명-2" aria-label="Permalink to “주요 함수 설명”">​</a></h3><ol><li><strong>cv2.findContours(image, mode, method)</strong> : 마스크 이미지(흑백)에서 흰색 영역의 경계선을 찾습니다.</li></ol><div class="info custom-block"><p class="custom-block-title">파라미터 설명</p><ul><li><strong><code>image</code></strong>: 반드시 이진화(흑백)된 이미지여야 합니다. (mask)</li><li><strong><code>mode</code></strong>: cv2.RETR_EXTERNAL을 쓰면 물체 안에 있는 구멍(도넛 모양의 내부)은 무시하고, 가장 바깥 테두리만 찾습니다.</li></ul></div><div class="danger custom-block"><p class="custom-block-title">리턴값</p><p>contours는 외곽선 좌표들의 리스트(List)입니다.</p></div><ol start="2"><li><strong>cv2.contourArea(cnt)</strong> : 찾아낸 외곽선이 차지하는 면적(픽셀 수)을 계산합니다.</li></ol><div class="info custom-block"><p class="custom-block-title">왜 필요한가요?</p><p>화면에 먼지 같은 파란색 점이 찍혀도 컴퓨터는 인식합니다. 이런 노이즈를 제거하기 위해 &quot;면적이 500 이상인 것만 그려라&quot;라는 조건문(if area &gt; MIN_AREA)을 사용합니다.</p></div><ol start="3"><li><strong>cv2.boundingRect(cnt)</strong> : 외곽선(cnt)을 감싸는 가장 작은 똑바른 사각형을 구합니다.</li></ol><div class="danger custom-block"><p class="custom-block-title">리턴값</p><p>x (왼쪽 위 가로), y (왼쪽 위 세로), w (폭), h (높이)</p></div><ol start="4"><li><strong>cv2.rectangle(img, pt1, pt2, color, thickness)</strong> : 이미지에 사각형을 그립니다.</li></ol><div class="info custom-block"><p class="custom-block-title">파라미터 설명</p><ul><li><strong><code>img</code></strong>: 사각형을 그릴 이미지입니다.</li><li><strong><code>pt1</code></strong>: 시작점 (x, y)</li><li><strong><code>pt2</code></strong>: 끝점 (x + w, y + h)</li><li><strong><code>color</code></strong>: 사각형의 색상입니다. (B, G, R) 형식의 튜플이나 스칼라 값으로 지정할 수 있습니다.</li><li><strong><code>thickness</code></strong>: 선택적으로 사각형의 선 두께를 지정합니다. 음수 값을 전달하면 내부를 채웁니다.</li></ul></div><div class="warning custom-block"><p class="custom-block-title">실습 과제</p><ol><li><p><strong>기초</strong>: 가장 큰 물체 하나만 잡기 지금 코드는 파란색 물체가 3개 있으면 박스도 3개가 생깁니다. 화면에 파란색이 여러 개 있어도, 가장 큰 물체 1개에만 박스를 그리도록 코드를 수정해보세요. 힌트: contours 리스트를 반복문 돌기 전에 max() 함수나 정렬을 이용해 면적이 제일 큰 녀석을 찾으세요.</p></li><li><p><strong>응용 1</strong>: 물체의 중심점 찍기 박스 중심에 빨간 점을 찍어보세요. 중심 좌표 공식: center_x = x + w // 2, center_y = y + h // 2</p></li><li><p><strong>응용 2</strong>: 컵/펜 추적하기 파란색 컵이나 파란색 뚜껑 펜을 준비해서 카메라 앞에서 흔들어보며 박스가 잘 따라오는지 테스트해보세요. MIN_AREA 값을 조절해가며 최적의 값을 찾아보세요.</p></li></ol></div></div></div></main><footer class="VPDocFooter" data-v-7011f0d8 data-v-e257564d><!--[--><!--]--><!----><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-e257564d><span class="visually-hidden" id="doc-footer-aria-label" data-v-e257564d>Pager</span><div class="pager" data-v-e257564d><a class="VPLink link pager-link prev" href="/minipi_guide/robot-app/remote.html" data-v-e257564d><!--[--><span class="desc" data-v-e257564d>Previous page</span><span class="title" data-v-e257564d>원격 제어</span><!--]--></a></div><div class="pager" data-v-e257564d><a class="VPLink link pager-link next" href="/minipi_guide/robot-app/qrcode.html" data-v-e257564d><!--[--><span class="desc" data-v-e257564d>Next page</span><span class="title" data-v-e257564d>마커 인식</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"ai-app_basic.md\":\"CnDg1mCF\",\"ai-app_index.md\":\"BHBPi3wR\",\"ai-app_rkllama.md\":\"Dnp-5bBM\",\"ai-app_voice.md\":\"CL0lwW8T\",\"ai-app_yolo.md\":\"CJQ3t6A5\",\"demo_ball_goal.md\":\"CvaKc1Ln\",\"demo_ball_tracking.md\":\"De9oydJF\",\"demo_index.md\":\"R6ysbJgC\",\"demo_using_llm.md\":\"B0JtkH61\",\"demo_web_gui.md\":\"BowL5Fo8\",\"hardware_comm.md\":\"nzGiGHnC\",\"hardware_control.md\":\"Bb7gekZG\",\"hardware_index.md\":\"BV_gKddO\",\"hardware_input.md\":\"DsPyWUSK\",\"hardware_mech.md\":\"BGqvgh3H\",\"hardware_output.md\":\"CgQDKkkG\",\"hardware_servo.md\":\"iuQ57ojB\",\"hardware_spec.md\":\"DDzjh3ol\",\"index.md\":\"De3Hav3l\",\"repair_index.md\":\"in9ve4Zd\",\"repair_maintain.md\":\"BWRcUPmT\",\"repair_repair_cable.md\":\"CK4UNOsm\",\"repair_repair_noboot.md\":\"ATKBCBC3\",\"rl-adv_imtation.md\":\"BkwA5hcB\",\"rl-adv_index.md\":\"DfMhsRQB\",\"rl-adv_release.md\":\"CNUAI8qi\",\"rl-adv_walk.md\":\"CmxBpzxM\",\"robot-app_basic.md\":\"Dg1ktFnD\",\"robot-app_index.md\":\"BjRD2GGc\",\"robot-app_move.md\":\"BvNxCMaX\",\"robot-app_node.md\":\"DGGmqJgu\",\"robot-app_opencv.md\":\"Bllbrakc\",\"robot-app_qrcode.md\":\"CxCwXlV_\",\"robot-app_remote.md\":\"BzzNRUw_\",\"robot-app_webui.md\":\"LZU4KBdI\",\"ros-basic_index.md\":\"CLgGv5_m\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"Mini Pi Guide\",\"description\":\"2족 보행 로봇 활용\",\"base\":\"/minipi_guide/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"Home\",\"link\":\"/\"},{\"text\":\"WeGo\",\"link\":\"https://wego-robotics.com/\"}],\"sidebar\":{\"/hardware/\":[{\"text\":\"Mini Pi 로봇의 하드웨어\",\"items\":[{\"text\":\"개요\",\"link\":\"/hardware/\"},{\"text\":\"사양 파악하기\",\"link\":\"/hardware/spec\"},{\"text\":\"기계 기구부\",\"link\":\"/hardware/mech\"},{\"text\":\"구동계(엑추에이터)\",\"link\":\"/hardware/servo\"},{\"text\":\"제어 시스템\",\"link\":\"/hardware/control\"},{\"text\":\"통신 시스템\",\"link\":\"/hardware/comm\"},{\"text\":\"입력 장치(센서)\",\"link\":\"/hardware/input\"},{\"text\":\"출력 장치\",\"link\":\"/hardware/output\"}]}],\"/robot-app/\":[{\"text\":\"Mini Pi 로봇의 응용\",\"items\":[{\"text\":\"개요\",\"link\":\"/robot-app/\"},{\"text\":\"기본 사용법\",\"link\":\"/robot-app/basic\"},{\"text\":\"노드 매니저\",\"link\":\"/robot-app/node\"},{\"text\":\"로봇의 이동\",\"link\":\"/robot-app/move\"},{\"text\":\"웹UI 다루기\",\"link\":\"/robot-app/webui\"},{\"text\":\"원격 제어\",\"link\":\"/robot-app/remote\"},{\"text\":\"물체 추적\",\"link\":\"/robot-app/opencv\"},{\"text\":\"마커 인식\",\"link\":\"/robot-app/qrcode\"}]}],\"/ai-app/\":[{\"text\":\"Mini Pi 로봇과 AI 기본\",\"items\":[{\"text\":\"개요\",\"link\":\"/ai-app/\"},{\"text\":\"로봇에서 NPU 사용하기\",\"link\":\"/ai-app/basic\"},{\"text\":\"YOLO AI 이용해서 물체 인식하기\",\"link\":\"/ai-app/yolo\"},{\"text\":\"음성인식 & TTS\",\"link\":\"/ai-app/voice\"},{\"text\":\"LLM 사용하기\",\"link\":\"/ai-app/rkllama\"}]}],\"/rl-adv/\":[{\"text\":\"Mini Pi 로봇과 AI 심화\",\"items\":[{\"text\":\"개요\",\"link\":\"/rl-adv/\"},{\"text\":\"보행 강화 학습\",\"link\":\"/rl-adv/walk\"},{\"text\":\"영상 모방 학습\",\"link\":\"/rl-adv/imtation\"},{\"text\":\"AI 모델 배포\",\"link\":\"/rl-adv/release\"}]}],\"/repair/\":[{\"text\":\"Mini Pi 로봇의 유지보수\",\"items\":[{\"text\":\"개요\",\"link\":\"/repair/\"},{\"text\":\"큰 고장을 막기 위한 관찰\",\"link\":\"/repair/maintain\"},{\"text\":\"관절 케이블 교체 수리 방법\",\"link\":\"/repair/repair_cable\"},{\"text\":\"부팅 안 될 경우 수리 방법\",\"link\":\"/repair/repair_noboot\"}]}],\"/demo/\":[{\"text\":\"Mini Pi 데모 매뉴얼\",\"items\":[{\"text\":\"개요\",\"link\":\"/demo/\"},{\"text\":\"공 추적\",\"link\":\"/demo/ball_tracking\"},{\"text\":\"공 골대 넣기\",\"link\":\"/demo/ball_goal\"},{\"text\":\"LLM 사용\",\"link\":\"/demo/using_llm\"},{\"text\":\"웹 GUI 사용\",\"link\":\"/demo/web_gui\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/WeGo-Robotics\"}]},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false,\"additionalConfig\":{}}");</script>
    
  </body>
</html>