import{_ as i,c as s,o as t,ah as e,aC as l,aD as n,aE as r,aH as h,aI as p,aJ as k,aK as o,aL as c}from"./chunks/framework.Bb6kz8E2.js";const f=JSON.parse('{"title":"데모 실행 매뉴얼","description":"","frontmatter":{},"headers":[],"relativePath":"demo/ball_tracking.md","filePath":"demo/ball_tracking.md"}'),d={name:"demo/ball_tracking.md"};function g(b,a,m,_,u,y){return t(),s("div",null,[...a[0]||(a[0]=[e('<h1 id="데모-실행-매뉴얼" tabindex="-1">데모 실행 매뉴얼 <a class="header-anchor" href="#데모-실행-매뉴얼" aria-label="Permalink to “데모 실행 매뉴얼”">​</a></h1><h2 id="공-추적하기" tabindex="-1">공 추적하기 <a class="header-anchor" href="#공-추적하기" aria-label="Permalink to “공 추적하기”">​</a></h2><h3 id="바로-사용하기-nomachine을-이용한-gui" tabindex="-1">바로 사용하기 (nomachine을 이용한 GUI) <a class="header-anchor" href="#바로-사용하기-nomachine을-이용한-gui" aria-label="Permalink to “바로 사용하기 (nomachine을 이용한 GUI)”">​</a></h3><p>새 터미널을 켜거나, 기존 터미널에서 <code>source ~/.bashrc</code>를 입력하면 아래 사진과 같이 단축어가 나옵니다.</p><img src="'+l+'" alt="초기 단축" width="100%" style="display:block;margin:0 auto;"><p>차례대로 <code>soccer_ws</code>, <code>roboworld_gui</code>를 입력하세요.</p><img src="'+n+'" alt="gui 실행" width="100%" style="display:block;margin:0 auto;"><p>아래와 같이 GUI 창이 나타납니다.</p><img src="'+r+'" alt="gui 메인" width="100%" style="display:block;margin:0 auto;"><p>아래처럼 표시된 항목을 재생하십시오.</p><p>twist_mux는 조이스틱, 기타 코드 등에서 내보내는 로봇 조종 명령 간 우선순위를 결정합니다. <img src="'+h+'" alt="gui 설정" width="50%" style="display:block;margin:0 auto;"></p><p>avoid_wall은 근처의 벽이나 장애물을 마주쳤을 때 회전하도록 하며, mux_discrete_track_efficient가 공을 추적하도록 합니다. <img src="'+p+'" alt="gui 설정" width="50%" style="display:block;margin:0 auto;"></p><h3 id="바로-사용하기-웹-gui-접속" tabindex="-1">바로 사용하기 (웹 GUI 접속) <a class="header-anchor" href="#바로-사용하기-웹-gui-접속" aria-label="Permalink to “바로 사용하기 (웹 GUI 접속)”">​</a></h3><p>기본적으로, 로봇을 켜거나 다시 로그인 할 때 자동으로 웹 GUI에 접속 할 수 있는 설정이 완료됩니다.</p><p>위에서와 같은 항목을 재생하십시오.</p><img src="'+k+'" alt="웹 설정" width="100%" style="display:block;margin:0 auto;"><hr><h2 id="커스텀환경에서-공-추적하기" tabindex="-1">커스텀환경에서 공 추적하기 <a class="header-anchor" href="#커스텀환경에서-공-추적하기" aria-label="Permalink to “커스텀환경에서 공 추적하기”">​</a></h2><p>mini pi는 rk3588기반 npu가 지원됩니다. 따라서 yolo학습 이후 나오는 .pt 파일을 .rknn 파일로 바꾸어 적용할 수 있습니다.</p><p>기존 mini pi에서 제공되는 공 추적 알고리즘에서 공이 제대로 검출되지 않는다면 사용 환경에서 새로 학습을 수행할 수 있습니다.</p><p>단계는 다음과 같습니다.</p><ol><li>공 데이터셋 수집</li><li>YOLO 학습</li><li>학습된 YOLO pt 모델 rknn 변환</li><li>rknn을 공 추적 launch 파일에 지정</li></ol><h4 id="_1-공-데이터셋-수집" tabindex="-1">1. 공 데이터셋 수집 <a class="header-anchor" href="#_1-공-데이터셋-수집" aria-label="Permalink to “1. 공 데이터셋 수집”">​</a></h4><p>조종을 하기 위해서 위의 twist_mux.launch를 실행해줍니다.</p><p>아래 명령어를 입력합니다. 기본적으로 /usb_cam/image_raw 토픽을 실행하도록 되어있으며, 해당토픽을 실행하기 위한 명령어도 자동으로 수행됩니다. bag_prefix를 통해 저장할 bag파일 이름을 정할 수 있습니다. 정하지 않을 경우, 자동으로 img_dataset으로 지정되며, 이전에 같은 이름이 있을 경우 덮어씌워집니다.</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;user-select:none;-webkit-user-select:none;">$ </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">roslaunch</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> dataset_making</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> record_bag.launch</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bag_prefix:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">저장할</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 파일</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 이름</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>이 명령어를 수행한 후, 직접 로봇을 움직이면 자동으로 이미지 토픽들이 .bag 파일에 저장됩니다. ctrl+c를 통해 녹화를 끝내면 /home/hightorque/soccer_ws/src/dataset_making/bags에 &quot;bag_prefix&quot;.bag 으로 bag 파일이 저장됩니다.</p><p>이후, 아래 명령어를 통해 bag파일로부터 이미지를 추출하여 저장합니다. bag_filename에는 이미지로 추출할 bag파일의 전체 경로를 넣어주세요.</p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;user-select:none;-webkit-user-select:none;">$ </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">roslaunch</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> dataset_making</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> get_image.launch</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bag_filename:=/home/hightorque/soccer_ws/src/dataset_making/bags/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bag파일</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 이름</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.bag</span></span></code></pre></div><h4 id="_2-yolo-학습" tabindex="-1">2. YOLO 학습 <a class="header-anchor" href="#_2-yolo-학습" aria-label="Permalink to “2. YOLO 학습”">​</a></h4><p>추출된 이미지를 라벨링하여 yolo로 학습합니다. 라벨링하는 프로그램은 다양하지만, roboflow를 추천합니다. <a href="https://roboflow.com/" target="_blank" rel="noreferrer">https://roboflow.com/</a></p><p>yolo 학습은 아래 링크를 참고해주세요. <a href="https://docs.ultralytics.com/quickstart/#use-ultralytics-with-cli" target="_blank" rel="noreferrer">https://docs.ultralytics.com/quickstart/#use-ultralytics-with-cli</a></p><h4 id="_3-학습된-yolo-pt-모델-rknn-변환" tabindex="-1">3. 학습된 YOLO pt 모델 rknn 변환 <a class="header-anchor" href="#_3-학습된-yolo-pt-모델-rknn-변환" aria-label="Permalink to “3. 학습된 YOLO pt 모델 rknn 변환”">​</a></h4><p>YOLO를 학습한 이후, best.pt 와 같이 모델이 나옵니다. rk3588에서 사용할 수 있는 rknn 변환을 지원하므로, 이를 사용하면 yolo 라이브러리 설치 없이 간단하게 사용할 수 있습니다.</p><p><a href="https://docs.ultralytics.com/ko/integrations/rockchip-rknn/#summary" target="_blank" rel="noreferrer">https://docs.ultralytics.com/ko/integrations/rockchip-rknn/#summary</a></p><div class="language-bash"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;user-select:none;-webkit-user-select:none;">$ </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">yolo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> export</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> model=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">변경할</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pt</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 모델</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">format=rknn</span></span></code></pre></div><p>이후, .rknn과 모델의 정보가 든 metadata.yaml이 생성됩니다.</p><h4 id="rknn을-공-추적-launch-파일에-지정" tabindex="-1">rknn을 공 추적 launch 파일에 지정 <a class="header-anchor" href="#rknn을-공-추적-launch-파일에-지정" aria-label="Permalink to “rknn을 공 추적 launch 파일에 지정”">​</a></h4><p>생성된 .rknn과 metadata.yaml을 공 추적에 사용되는 launch 파일에 저장합니다.</p><p>아래 사진과 같이 soccer_ws/src/yolo11_detect_pkg/config/rknn에 저장합니다.</p><img src="'+o+'" alt="파일 저장 경로" width="30%" style="display:block;margin:0 auto;"><p>이후, yolo11_detect_pkg의 yolo_detect_efficient_d435.launch에서 rknn_file과 yaml_file의 기본 경로를 변경합니다.</p><img src="'+c+'" alt="launch 파일 설정" width="100%" style="display:block;margin:0 auto;">',43)])])}const E=i(d,[["render",g]]);export{f as __pageData,E as default};
