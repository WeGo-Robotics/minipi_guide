import{_ as a,c as n,o as t,ah as l,bW as p,bX as h,bY as i,bZ as e}from"./chunks/framework.B6i8j-aH.js";const u=JSON.parse('{"title":"OpenCV란?","description":"","frontmatter":{},"headers":[],"relativePath":"robot-app/opencv.md","filePath":"robot-app/opencv.md"}'),k={name:"robot-app/opencv.md"};function r(d,s,o,E,g,c){return t(),n("div",null,[...s[0]||(s[0]=[l(`<h1 id="opencv란" tabindex="-1">OpenCV란? <a class="header-anchor" href="#opencv란" aria-label="Permalink to “OpenCV란?”">​</a></h1><p>OpenCV(Open Source Computer Vision Library)는 <strong>이미지와 영상 처리·분석을 위한 오픈소스 라이브러리</strong>입니다.<br> 카메라로부터 입력된 화면을 분석하여 <strong>사물을 인식하고 판단하는 역할</strong>을 수행합니다.</p><h2 id="opencv를-사용하는-이유" tabindex="-1">OpenCV를 사용하는 이유 <a class="header-anchor" href="#opencv를-사용하는-이유" aria-label="Permalink to “OpenCV를 사용하는 이유”">​</a></h2><p>OpenCV를 사용하는 이유는 다음과 같습니다.</p><table tabindex="0"><thead><tr><th>기능</th><th>설명</th><th>로봇 적용 예시</th></tr></thead><tbody><tr><td>이미지 분석</td><td>색, 윤곽선, 객체 형태 인식</td><td>공/사람 인식</td></tr><tr><td>영상 처리</td><td>실시간 카메라 프레임 처리</td><td>라인 추적 로봇</td></tr><tr><td>위치 계산</td><td>객체 중심점, 거리 추정</td><td>목표 추적 및 장애물 회피</td></tr><tr><td>제어 연결</td><td>분석 결과를 ROS 등으로 전달</td><td>로봇 속도 제어</td></tr></tbody></table><blockquote><p>즉, <strong>로봇에게 눈(vision)을 제공하는 핵심 기술</strong>입니다.</p></blockquote><h2 id="opencv-영상-처리-흐름" tabindex="-1">OpenCV 영상 처리 흐름 <a class="header-anchor" href="#opencv-영상-처리-흐름" aria-label="Permalink to “OpenCV 영상 처리 흐름”">​</a></h2><div class="tip custom-block"><p class="custom-block-title">OpenCV 영상 처리 단계</p><p>카메라 영상 취득 -&gt; 이미지 데이터 변환 -&gt; 이미지 전처리 -&gt; 이미지에서 데이터 추출</p></div><ol><li><strong>카메라에서 영상 취득</strong> : 시스템에 연결된 카메라를 선택하고 해상도나 밝기 등의 설정을 한 후 영상을 캡쳐합니다.</li><li><strong>이미지 전처리</strong> : BGR -&gt; RGB -&gt; HSV 등으로 형식을 변환하고 이미지의 밝기, 대비, 색온도 등의 항목을 수정해 데이터 추출이 용이하게 합니다.</li><li><strong>이미지에서 데이터 추출</strong> : 이미지에서 색상, 엣지, 도형, 마커 등의 의미있는 데이터를 등을 추출합니다.</li></ol><div class="tip custom-block"><p class="custom-block-title">주의사항</p><p>OpenCV는 일반적인 RGB 순서가 아닌 BGR (Blue, Green, Red) 순서를 기본으로 사용합니다. (CV_8UC3일 때 0번 채널이 Blue입니다.)</p></div><h2 id="특정-색상-찾기-예제" tabindex="-1">특정 색상 찾기 예제 <a class="header-anchor" href="#특정-색상-찾기-예제" aria-label="Permalink to “특정 색상 찾기 예제”">​</a></h2><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numpy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> np</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 1. 카메라 설정</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cap </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv2.VideoCapture(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 파란색 범위 설정 (이전 시간 복습)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">lower_blue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> np.array([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">upper_blue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> np.array([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">140</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">255</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">255</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># ★ 핵심 변수: 인식할 최소 면적 (픽셀 수)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 이 값보다 작은 덩어리는 무시합니다. (값을 조절해보세요)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MIN_AREA</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 500</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">print</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;파란색 물체를 찾아 박스를 그립니다. (종료: q)&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> True</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ret, frame </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cap.read()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> not</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ret:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        break</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 2. 색상 추출 (HSV 변환 및 마스크 생성)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    hsv </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv2.cvtColor(frame, cv2.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">COLOR_BGR2HSV</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    mask </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv2.inRange(hsv, lower_blue, upper_blue)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # (옵션) 모폴로지 연산: 노이즈를 제거하여 마스크를 깔끔하게 만듦</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 파란색 영역의 구멍을 메우거나 자잘한 점을 없앰</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    kernel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> np.ones((</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), np.uint8)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    mask </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv2.morphologyEx(mask, cv2.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MORPH_OPEN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, kernel)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    mask </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv2.morphologyEx(mask, cv2.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MORPH_CLOSE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, kernel)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 3. 외곽선(Contour) 검출</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # cv2.RETR_EXTERNAL: 가장 바깥쪽 라인만 찾음 (구멍 뚫린 내부 라인 무시)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # cv2.CHAIN_APPROX_SIMPLE: 직선 구간은 끝점만 저장해 메모리 절약</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    contours, _ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv2.findContours(mask, cv2.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RETR_EXTERNAL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, cv2.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">CHAIN_APPROX_SIMPLE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 4. 발견된 모든 외곽선 순회</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cnt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> contours:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # 면적 계산</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        area </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv2.contourArea(cnt)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # ★ 크기 필터링: 면적이 설정값보다 클 때만 박스 그리기</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> area </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MIN_AREA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            # 외곽선을 감싸는 정사각 박스 좌표 구하기</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            # x, y: 시작점 좌표 / w, h: 폭과 높이</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            x, y, w, h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv2.boundingRect(cnt)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            # 원본 화면에 녹색 박스 그리기 (두께 2)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            cv2.rectangle(frame, (x, y), (x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> w, y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> h), (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">255</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            # 박스 위에 &quot;Blue Object&quot; 글자 쓰기</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            cv2.putText(frame, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Blue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (x, y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                        cv2.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FONT_HERSHEY_SIMPLEX</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">255</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 결과 출력</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    cv2.imshow(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Camera&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, frame)       </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 박스가 그려진 원본</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    cv2.imshow(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Mask&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, mask)          </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 흑백 마스크 (디버깅용)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv2.waitKey(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> 0x</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FF</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ord</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;q&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">):</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        break</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cap.release()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cv2.destroyAllWindows()</span></span></code></pre></div><h2 id="카메라에서-영상-취득-capture" tabindex="-1">카메라에서 영상 취득 (Capture) <a class="header-anchor" href="#카메라에서-영상-취득-capture" aria-label="Permalink to “카메라에서 영상 취득 (Capture)”">​</a></h2><p>OpenCV에서 동영상 파일이나 카메라 스트림을 다룰 때는 VideoCapture 클래스를 사용합니다.</p><div style="display:flex;justify-content:center;gap:20px;"><img src="`+p+`" alt="원본" style="width:45%;"></div><h3 id="주요-함수-설명" tabindex="-1">주요 함수 설명 <a class="header-anchor" href="#주요-함수-설명" aria-label="Permalink to “주요 함수 설명”">​</a></h3><ol><li><strong>cv2.VideoCapture(index)</strong> : VideoCapture 클래스 생성</li></ol><div class="info custom-block"><p class="custom-block-title">index</p><p>카메라 장치 번호를 지정합니다.</p><p>0: 보통 노트북의 내장 웹캠 혹은 첫 번째 연결된 카메라.</p><p>1, 2...: 추가로 연결된 USB 카메라.</p><p>&quot;video.mp4&quot;: 파일 경로를 넣으면 동영상을 재생합니다.</p></div><ol start="2"><li><strong>cap.read()</strong> : 영상을 한 프레임(한 장의 사진)씩 가져옵니다.</li></ol><div class="danger custom-block"><p class="custom-block-title">리턴값</p><p>(성공여부 Bool, 이미지배열 Numpy) 튜플을 반환하므로 반드시 두 변수로 받아야 합니다.</p></div><ol start="3"><li><strong>cv2.waitKey(delay)</strong> : 이 함수가 없으면 창이 뜨지 않거나 멈춥니다.</li></ol><div class="info custom-block"><p class="custom-block-title">delay</p><p>밀리초(ms) 단위 대기 시간입니다.</p><p>1: 1ms만 대기하고 다음 코드로 넘어감 (동영상/카메라용).</p><p>0: 키를 누를 때까지 무한 대기 (정지 영상용).</p></div><div class="danger custom-block"><p class="custom-block-title">리턴값</p><p>눌린 키의 아스키 코드 값입니다.</p></div><ol start="4"><li><strong>cap.release()</strong> : 프로그램이 끝날 때 카메라 장치 사용 권한을 운영체제에 반환해야 합니다. 그렇지 않으면 다른 프로그램(Zoom, Skype 등)에서 카메라를 쓰지 못할 수 있습니다.</li></ol><div class="warning custom-block"><p class="custom-block-title">실습 과제</p><ol><li><strong>기초</strong>: 위 코드를 실행하여 자기 얼굴 띄우기.</li><li><strong>응용 1 (좌우 반전)</strong>: 거울처럼 보이게 cv2.flip(frame, 1) 적용해보기.</li><li><strong>응용 2 (필터 적용)</strong>: cv2.cvtColor를 이용해 흑백(Grayscale) 영상으로 송출하기.</li><li><strong>응용 3 (캡처)</strong>: &#39;s&#39; 키를 누르면 현재 화면을 이미지 파일(my_photo.jpg)로 저장하기. (cv2.imwrite 사용)</li></ol></div><h2 id="이미지-전처리" tabindex="-1">이미지 전처리 <a class="header-anchor" href="#이미지-전처리" aria-label="Permalink to “이미지 전처리”">​</a></h2><ul><li>BGR → HSV 변환</li><li>파란색만 추출(Mask 생성)</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 2. 색상 추출 (HSV 변환 및 마스크 생성)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">hsv </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv2.cvtColor(frame, cv2.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">COLOR_BGR2HSV</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mask </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv2.inRange(hsv, lower_blue, upper_blue)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># (옵션) 모폴로지 연산: 노이즈를 제거하여 마스크를 깔끔하게 만듦</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 파란색 영역의 구멍을 메우거나 자잘한 점을 없앰</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">kernel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> np.ones((</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), np.uint8)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mask </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv2.morphologyEx(mask, cv2.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MORPH_OPEN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, kernel)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mask </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv2.morphologyEx(mask, cv2.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MORPH_CLOSE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, kernel)</span></span></code></pre></div><h3 id="주요-함수-설명-1" tabindex="-1">주요 함수 설명 <a class="header-anchor" href="#주요-함수-설명-1" aria-label="Permalink to “주요 함수 설명”">​</a></h3><ol><li><p><strong>cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)</strong> : 사람의 눈이 색을 인지하는 방식과 비슷하게 데이터를 바꾸는 과정입니다. 이 줄이 없으면 파란색 인식이 매우 불안정해집니다.</p></li><li><p><strong>cv2.inRange(src, lower, upper)</strong> : 이미지를 이진화(Binarization) 합니다.</p></li></ol><div class="info custom-block"><p class="custom-block-title">lower ~ upper</p><p>사이의 값은 255(흰색), 범위 밖은 <strong>0(검은색)</strong>으로 바꿉니다. 결과물인 mask는 흑백 이미지가 됩니다. 흰색 영역이 우리가 찾은 &quot;파란색 물체&quot;의 위치입니다.</p></div><ol start="3"><li><strong>cv2.morphologyEx(src, op, kernel, iterations=1)</strong> : OpenCV에서 고급 모폴로지(Morphology) 연산을 수행하는 범용 함수입니다. 한마디로 요약하면: <strong>&quot;이미지의 잡음(작은 흰색 점)을 제거하면서, 원래 물체의 크기는 보존하는 연산&quot;</strong>입니다.</li></ol><div class="info custom-block"><p class="custom-block-title">파라미터 설명</p><ul><li><strong><code>src</code></strong>: 입력 이미지 (주로 흑백 바이너리 이미지 또는 그레이스케일 이미지)</li><li><strong><code>op</code></strong>: 수행할 연산의 종류 (가장 중요한 파라미터, 아래 3번 항목 참조)</li><li><strong><code>kernel</code></strong>: 구조 요소(Structuring Element). <code>cv2.getStructuringElement()</code>나 <code>np.ones()</code>로 생성한 커널 행렬.</li><li><strong><code>iterations</code></strong> (선택): 연산 반복 횟수 (기본값은 1)</li></ul></div><div class="info custom-block"><p class="custom-block-title">주요 연산 종류 (<code>op</code> 옵션)</p><p>이 함수는 두 번째 인자(<code>op</code>)에 무엇을 넣느냐에 따라 기능이 완전히 달라집니다.</p><table tabindex="0"><thead><tr><th style="text-align:left;">옵션 상수 (<code>op</code>)</th><th style="text-align:left;">이름</th><th style="text-align:left;">동작 원리</th><th style="text-align:left;">주요 용도</th></tr></thead><tbody><tr><td style="text-align:left;"><strong><code>cv2.MORPH_OPEN</code></strong></td><td style="text-align:left;"><strong>열기 (Opening)</strong></td><td style="text-align:left;">침식 후 팽창<br>(Erosion → Dilation)</td><td style="text-align:left;"><strong>노이즈 제거</strong>, 작은 돌기 제거, 서로 붙은 물체 떼어내기</td></tr><tr><td style="text-align:left;"><strong><code>cv2.MORPH_CLOSE</code></strong></td><td style="text-align:left;"><strong>닫기 (Closing)</strong></td><td style="text-align:left;">팽창 후 침식<br>(Dilation → Erosion)</td><td style="text-align:left;"><strong>구멍 메우기</strong>, 끊어진 물체 이어 붙이기</td></tr><tr><td style="text-align:left;"><strong><code>cv2.MORPH_GRADIENT</code></strong></td><td style="text-align:left;"><strong>그라디언트</strong></td><td style="text-align:left;">팽창 - 침식<br>(Dilation - Erosion)</td><td style="text-align:left;"><strong>경계선(Edge) 검출</strong>, 물체의 외곽선 찾기</td></tr><tr><td style="text-align:left;"><strong><code>cv2.MORPH_TOPHAT</code></strong></td><td style="text-align:left;"><strong>탑햇 (Top Hat)</strong></td><td style="text-align:left;">원본 - 열기<br>(Src - Opening)</td><td style="text-align:left;"><strong>밝은 부분 강조</strong>, 배경이 어두울 때 국소적으로 밝은 미세한 부분 검출</td></tr><tr><td style="text-align:left;"><strong><code>cv2.MORPH_BLACKHAT</code></strong></td><td style="text-align:left;"><strong>블랙햇 (Black Hat)</strong></td><td style="text-align:left;">닫기 - 원본<br>(Closing - Src)</td><td style="text-align:left;"><strong>어두운 부분 강조</strong>, 배경이 밝을 때 국소적으로 어두운 미세한 부분 검출</td></tr></tbody></table></div><p>아래 사진은 모폴로지(Morphology) 처리를 하기 전과 후이다.</p><div style="display:flex;justify-content:center;gap:20px;"><img src="`+h+'" alt="원본 마스크" style="width:45%;"><img src="'+i+`" alt="모폴로지 연산 후" style="width:45%;"></div><h3 id="hsv를-왜-쓰는가" tabindex="-1">HSV를 왜 쓰는가? <a class="header-anchor" href="#hsv를-왜-쓰는가" aria-label="Permalink to “HSV를 왜 쓰는가?”">​</a></h3><p>카메라에서 들어오는 원본 이미지는 보통 <strong>BGR</strong>형식입니다.<br> 하지만 BGR에서는 밝기 변화(조명)에 따라 같은 물체도 값이 크게 바뀌어서 색으로 물체를 찾기 까다롭습니다.<br> 그래서 색 추적에는 보통 <strong>HSV(Hue, Saturation, Value)</strong> 색공간을 사용합니다.</p><ul><li><strong>H(Hue)</strong> : 색상(빨강, 초록, 파랑 등), OpenCV에서 H의 범위: 0 ~ 179</li><li><strong>S(Saturation)</strong> : 색의 진함 정도 (원색에 가까운지)</li><li><strong>V(Value)</strong> : 색의 밝기</li></ul><p>💡 <strong>핵심</strong>: HSV 모델에서는 밝기(V)가 변해도 색상(H) 값은 거의 변하지 않으므로 특정 색을 검출하기 훨씬 쉽습니다.</p><p>HSV 범위 지정은 다음과 같이 작성할 수 있습니다.</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span># 파란색 영역 마스크 생성 (Hue: 100~140)</span></span>
<span class="line"><span>lower_blue = np.array([100, 100, 50])</span></span>
<span class="line"><span>upper_blue = np.array([140, 255, 255])</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 빨간색은 Hue 값이 0 근처와 180 근처 두 군데에 존재함</span></span>
<span class="line"><span>lower_red1 = np.array([0, 50, 50])</span></span>
<span class="line"><span>upper_red1 = np.array([10, 255, 255])</span></span>
<span class="line"><span>lower_red2 = np.array([170, 50, 50])</span></span>
<span class="line"><span>upper_red2 = np.array([180, 255, 255])</span></span>
<span class="line"><span></span></span>
<span class="line"><span>mask1 = cv2.inRange(hsv, lower_red1, upper_red1)</span></span>
<span class="line"><span>mask2 = cv2.inRange(hsv, lower_red2, upper_red2)</span></span>
<span class="line"><span>mask = mask1 + mask2 # 두 마스크 합치기</span></span></code></pre></div><p>각 값들 순서대로 H, S, V이며 현재 예시로 되어있는 코드는 파란색을 인식하도록 되어있습니다.</p><h2 id="이미지에서-데이터-추출" tabindex="-1">이미지에서 데이터 추출 <a class="header-anchor" href="#이미지에서-데이터-추출" aria-label="Permalink to “이미지에서 데이터 추출”">​</a></h2><ul><li>이진화된 이미지(Mask)에서 <strong>외곽선(Contour)</strong>을 찾을 수 있다.</li><li><strong>contourArea</strong>를 사용하여 작은 노이즈(잡음)는 무시하고, 큰 물체만 골라낸다.</li><li>물체의 위치를 계산하여 <strong>사각형 박스(Bounding Box)</strong>를 그릴 수 있다.</li></ul><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 면적 계산</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">area </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv2.contourArea(cnt)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># ★ 크기 필터링: 면적이 설정값보다 클 때만 박스 그리기</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> area </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MIN_AREA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 외곽선을 감싸는 정사각 박스 좌표 구하기</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # x, y: 시작점 좌표 / w, h: 폭과 높이</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    x, y, w, h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cv2.boundingRect(cnt)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # 원본 화면에 녹색 박스 그리기 (두께 2)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    cv2.rectangle(frame, (x, y), (x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> w, y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> h), (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">255</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><div style="display:flex;justify-content:center;gap:20px;"><img src="`+e+'" alt="원본 마스크" style="width:45%;"><img src="'+i+'" alt="모폴로지 연산 후" style="width:45%;"></div><h3 id="주요-함수-설명-2" tabindex="-1">주요 함수 설명 <a class="header-anchor" href="#주요-함수-설명-2" aria-label="Permalink to “주요 함수 설명”">​</a></h3><ol><li><strong>cv2.findContours(image, mode, method)</strong> : 마스크 이미지(흑백)에서 흰색 영역의 경계선을 찾습니다.</li></ol><div class="info custom-block"><p class="custom-block-title">파라미터 설명</p><ul><li><strong><code>image</code></strong>: 반드시 이진화(흑백)된 이미지여야 합니다. (mask)</li><li><strong><code>mode</code></strong>: cv2.RETR_EXTERNAL을 쓰면 물체 안에 있는 구멍(도넛 모양의 내부)은 무시하고, 가장 바깥 테두리만 찾습니다.</li></ul></div><div class="danger custom-block"><p class="custom-block-title">리턴값</p><p>contours는 외곽선 좌표들의 리스트(List)입니다.</p></div><ol start="2"><li><strong>cv2.contourArea(cnt)</strong> : 찾아낸 외곽선이 차지하는 면적(픽셀 수)을 계산합니다.</li></ol><div class="info custom-block"><p class="custom-block-title">왜 필요한가요?</p><p>화면에 먼지 같은 파란색 점이 찍혀도 컴퓨터는 인식합니다. 이런 노이즈를 제거하기 위해 &quot;면적이 500 이상인 것만 그려라&quot;라는 조건문(if area &gt; MIN_AREA)을 사용합니다.</p></div><ol start="3"><li><strong>cv2.boundingRect(cnt)</strong> : 외곽선(cnt)을 감싸는 가장 작은 똑바른 사각형을 구합니다.</li></ol><div class="danger custom-block"><p class="custom-block-title">리턴값</p><p>x (왼쪽 위 가로), y (왼쪽 위 세로), w (폭), h (높이)</p></div><ol start="4"><li><strong>cv2.rectangle(img, pt1, pt2, color, thickness)</strong> : 이미지에 사각형을 그립니다.</li></ol><div class="info custom-block"><p class="custom-block-title">파라미터 설명</p><ul><li><strong><code>img</code></strong>: 사각형을 그릴 이미지입니다.</li><li><strong><code>pt1</code></strong>: 시작점 (x, y)</li><li><strong><code>pt2</code></strong>: 끝점 (x + w, y + h)</li><li><strong><code>color</code></strong>: 사각형의 색상입니다. (B, G, R) 형식의 튜플이나 스칼라 값으로 지정할 수 있습니다.</li><li><strong><code>thickness</code></strong>: 선택적으로 사각형의 선 두께를 지정합니다. 음수 값을 전달하면 내부를 채웁니다.</li></ul></div><div class="warning custom-block"><p class="custom-block-title">실습 과제</p><ol><li><p><strong>기초</strong>: 가장 큰 물체 하나만 잡기 지금 코드는 파란색 물체가 3개 있으면 박스도 3개가 생깁니다. 화면에 파란색이 여러 개 있어도, 가장 큰 물체 1개에만 박스를 그리도록 코드를 수정해보세요. 힌트: contours 리스트를 반복문 돌기 전에 max() 함수나 정렬을 이용해 면적이 제일 큰 녀석을 찾으세요.</p></li><li><p><strong>응용 1</strong>: 물체의 중심점 찍기 박스 중심에 빨간 점을 찍어보세요. 중심 좌표 공식: center_x = x + w // 2, center_y = y + h // 2</p></li><li><p><strong>응용 2</strong>: 컵/펜 추적하기 파란색 컵이나 파란색 뚜껑 펜을 준비해서 카메라 앞에서 흔들어보며 박스가 잘 따라오는지 테스트해보세요. MIN_AREA 값을 조절해가며 최적의 값을 찾아보세요.</p></li></ol></div>',58)])])}const F=a(k,[["render",r]]);export{u as __pageData,F as default};
